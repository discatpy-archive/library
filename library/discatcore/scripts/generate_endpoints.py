import argparse
import builtins
import contextlib
import json
import pathlib
import sys
import types
import typing as t
from enum import Enum, auto

#
#  Constants
#

DEFAULT_SOURCE_DIR: t.Final[str] = "data/endpoints"
DEFAULT_DEST_DIR: t.Final[str] = "discatcore/http/endpoints"
VALID_METHODS: t.Final[list[str]] = ["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH"]
GENERATION_COMMENT: t.Final[
    str
] = "# this file was auto-generated by scripts/generate_endpoints.py"
IMPORTS: t.Final[dict[str, str]] = {
    "typing": "import typing as t",
    "discord_typings": "import discord_typings as dt",
    "BasicFile": "from ...file import BasicFile",
    "Unset": "from ...types import Unset, UnsetOr",
}
FILE_TEMPLATE: t.Final[
    str
] = f"""# SPDX-License-Identifier: MIT

{GENERATION_COMMENT}

{{0}}
from .core import EndpointMixin
from ..route import Route

__all__ = ("{{1}}",)

class {{1}}(EndpointMixin):
{{2}}

"""
INIT_HEADER: t.Final[
    str
] = f"""\"\"\"
discatcore.http.endpoints
~~~~~~~~~~~~~~~~~~~~~~~~~

The implementations for Discord API endpoints. These are for internal use only, use
`discatcore.http.HTTPClient` instead.
\"\"\"

{GENERATION_COMMENT}

"""
T = t.TypeVar("T")


class UnsetType(Enum):
    Unset = auto()


Unset: t.Literal[UnsetType.Unset] = UnsetType.Unset
UnsetOr = t.Union[T, UnsetType]


if sys.version_info >= (3, 10):
    from types import EllipsisType
else:
    if t.TYPE_CHECKING:
        EllipsisType = ellipsis
    else:
        EllipsisType = type(...)


#
#  Function Creator
#


# taken from typing
# https://github.com/python/cpython/blob/3.10/Lib/typing.py#L185-L203
def _type_repr(obj: t.Any) -> str:
    """Return the repr() of an object, special-casing types (internal helper).
    If obj is a type, we return a shorter version than the default
    type.__repr__, based on the module and qualified name, which is
    typically enough to uniquely identify a type.  For everything
    else, we fall back on repr(obj).
    """
    if isinstance(obj, types.GenericAlias):
        return repr(obj)
    if isinstance(obj, type):
        if obj.__module__ == "builtins":
            return obj.__qualname__
        return f"{obj.__module__}.{obj.__qualname__}"
    if obj is ...:
        return "..."
    if isinstance(obj, types.FunctionType):
        return obj.__name__
    return repr(obj)


class FunctionArg:
    def __init__(
        self,
        name: t.Optional[str] = None,
        *,
        annotation: UnsetOr[str] = Unset,
        default: UnsetOr[str] = Unset,
        pos_and_kw: bool = True,
        pos_modifier: bool = False,
        kw_modifier: bool = False,
        variable_pos: bool = False,
        variable_kw: bool = False,
    ):
        self.name: t.Optional[str] = name
        self.annotation: UnsetOr[str] = annotation
        self.default: UnsetOr[str] = default
        self.pos_and_kw: bool = pos_and_kw
        self.pos_modifier: bool = pos_modifier
        self.kw_modifier: bool = kw_modifier
        self.variable_pos: bool = variable_pos
        self.variable_kw: bool = variable_kw

        if self.pos_modifier and self.kw_modifier:
            raise ValueError(
                f"arg {self.name} cannot be both a positional modifier and a keyword modifier!"
            )
        if self.variable_pos and self.variable_kw:
            raise ValueError(
                f"arg {self.name} cannot be both a variable positional argument and a variable keyword argument!"
            )
        if (self.pos_modifier or self.kw_modifier) and (
            self.variable_pos or self.variable_kw
        ):
            raise ValueError(
                f"arg {self.name} cannot be both a modifier and a variable argument!"
            )
        if (self.pos_modifier or self.kw_modifier) and self.name:
            raise ValueError(f"arg {self.name} cannot be a modifier and have a name!")
        elif not (self.pos_modifier or self.kw_modifier) and not self.name:
            raise ValueError(f"non-modifier args require a name!")
        if (self.pos_modifier or self.kw_modifier) and self.annotation is not Unset:
            raise ValueError(f"modifier args cannot have annotations!")


def indent(text: str, *, level: int = 1) -> str:
    return "    " * level + text


class FunctionCreator:
    """A class that can dynamically create a function in a nice, OOP styled fashion.

    Args:
        name (str): The name of this function.
        decorators (t.Optional[List[:class:`str`]]): The list of decorators for this function. Defaults to None.
        is_async (bool): Whether or not this function is asynchronous. Defaults to False.

    Attributes:
        func_args (List[:class:`FunctionArg`]): The list of arguments for this function.
    """

    def __init__(
        self,
        name: str,
        *,
        decorators: t.Optional[list[str]] = None,
        is_async: bool = False,
    ) -> None:
        self.func_name: str = name
        self.func_async: bool = is_async
        self.func_args: list[FunctionArg] = []
        self.func_return_anno: t.Union[str, EllipsisType] = ...
        self.func_decorators: t.Optional[list[str]] = decorators
        self.func_body: list[str] = []
        self.func_indent_level: int = 1

    def insert_arg(self, arg: FunctionArg, index: int) -> None:
        self.func_args.insert(index, arg)

    def append_arg(self, arg: FunctionArg) -> None:
        self.func_args.append(arg)

    def remove_arg(self, index: int) -> None:
        del self.func_args[index]

    @contextlib.contextmanager
    def indent(self):
        self.func_indent_level += 1
        try:
            yield
        finally:
            self.func_indent_level -= 1

    def print(self, *args: str) -> None:
        if not args:
            self.func_body.append("")
        else:
            self.func_body.extend(
                [indent(arg, level=self.func_indent_level) for arg in args]
            )

    def print_block(self, lines: str) -> None:
        for line in lines.splitlines():
            self.print(line)

    def _convert_arg_to_str(self, arg: FunctionArg) -> str:
        str_arg: str = ""

        if (arg.variable_pos or arg.variable_kw or arg.pos_and_kw) and arg.name:
            if arg.variable_pos or arg.variable_kw:
                str_arg += "*" * (arg.variable_pos or arg.variable_kw * 2)
            str_arg += arg.name

            if arg.annotation is not Unset:
                str_arg += f": {arg.annotation}"
            if arg.default is not Unset:
                str_arg += f" = {arg.default}"
        else:
            str_arg += "*" if arg.kw_modifier else "/"

        return str_arg

    def generate_raw(self) -> str:
        func_str = ""
        if self.func_async:
            func_str += "async "

        str_args = ", ".join([self._convert_arg_to_str(arg) for arg in self.func_args])
        func_str += f"def {self.func_name}({str_args})"
        if self.func_return_anno is not ...:
            func_str += f" -> {self.func_return_anno}"
        func_str += ":\n" + "\n".join(self.func_body)

        return func_str

    def generate(
        self, *, globals: dict[str, t.Any] = {}, locals: dict[str, t.Any] = {}
    ) -> types.FunctionType:
        if "BUILTINS" not in locals:
            locals["BUILTINS"] = builtins

        func_str = "\n".join(
            [indent(line) for line in self.generate_raw().splitlines()]
        )
        local_vars = ", ".join(locals.keys())
        func_creator_str = (
            f"def __create_fn__({local_vars}):\n{func_str}\n    return {self.func_name}"
        )

        ns = {}
        exec(func_creator_str, globals, ns)

        # since pyright is a static type checker, it doesn't know the type of what was generated
        # in the ns
        func = ns["__create_fn__"](**locals)  # type: ignore
        if not isinstance(func, types.FunctionType):
            raise TypeError(
                f"the generated object was of type {type(func)!r}, not types.FunctionType!"  # type: ignore
            )
        return func


#
#  JSON Parsing
#


@t.overload
def _dict_type_check(d: dict[t.Any, t.Any], key: t.Any, expected_type: type[T]) -> T:
    ...


@t.overload
def _dict_type_check(
    d: dict[t.Any, t.Any],
    key: t.Any,
    expected_type: type[T],
    *,
    is_required: bool = ...,
) -> UnsetOr[T]:
    ...


def _dict_type_check(
    d: dict[t.Any, t.Any],
    key: t.Any,
    expected_type: type[T],
    *,
    is_required: bool = True,
) -> UnsetOr[T]:
    val = d.get(key, ...)
    if val is ... and is_required:
        raise KeyError(key)
    elif val is ...:
        return Unset

    origin = t.get_origin(expected_type)

    if isinstance(val, origin or expected_type):
        return val
    raise TypeError(
        f"the value at key {key} is not of type {_type_repr(expected_type)}!"
    )


def _generate_func_args_json_query(
    func_gen: FunctionCreator,
    params: dict[str, t.Union[str, list[t.Any]]],
) -> None:
    for param_name, param in params.items():
        default = Unset
        if isinstance(param, str):
            anno = param
        # fmt: off
        elif (
            isinstance(param, list) and len(param) == 2  # pyright: ignore[reportUnnecessaryIsInstance]
        ):
            anno, default = param
        # fmt: on
        else:
            raise TypeError(
                f"Invalid type {_type_repr(param)} for JSON/Query parameter values"
            )

        func_gen.append_arg(FunctionArg(param_name, annotation=anno, default=default))


def _generate_func_args(
    func_gen: FunctionCreator,
    url_params: UnsetOr[dict[t.Any, t.Any]],
    json_params: UnsetOr[dict[t.Any, t.Any]],
    query_params: UnsetOr[dict[t.Any, t.Any]],
    extra_params: UnsetOr[dict[t.Any, t.Any]],
) -> None:
    if url_params is not Unset:
        for param_name, param_anno in url_params.items():
            func_gen.append_arg(FunctionArg(param_name, annotation=param_anno))

    if (
        json_params is not Unset
        or query_params is not Unset
        or extra_params is not Unset
    ):
        func_gen.append_arg(FunctionArg(kw_modifier=True))

        if json_params is not Unset:
            _generate_func_args_json_query(func_gen, json_params)

        if query_params is not Unset:
            _generate_func_args_json_query(func_gen, query_params)

        if extra_params is not Unset:
            _generate_func_args_json_query(func_gen, extra_params)


def parse_endpoint_func(name: str, func: dict[str, t.Any]) -> tuple[str, list[str]]:
    method = _dict_type_check(func, "method", str)
    if method not in VALID_METHODS:
        raise ValueError(f"Invalid method {method}!")
    url = _dict_type_check(func, "url", str)
    url_params: UnsetOr[dict[str, str]] = _dict_type_check(
        func, "url-parameters", dict, is_required=False
    )
    json_params: UnsetOr[dict[str, t.Union[str, list[str]]]] = _dict_type_check(
        func, "json-parameters", dict, is_required=False
    )
    query_params: UnsetOr[dict[str, t.Union[str, list[str]]]] = _dict_type_check(
        func, "query-parameters", dict, is_required=False
    )
    extra_params: UnsetOr[dict[str, t.Union[str, list[str]]]] = _dict_type_check(
        func, "extra-parameters", dict, is_required=False
    )
    extra_request_params: UnsetOr[dict[str, str]] = _dict_type_check(
        func, "extra-request-parameters", dict, is_required=False
    )
    extra_code: list[str] = list(func.get("extra-code", []))
    supports_reason = bool(func.get("supports-reason"))
    supports_files = bool(func.get("supports-files"))

    func_generator = FunctionCreator(name, is_async=False)
    needed_imports: list[str] = []

    # generate arguments
    func_generator.append_arg(FunctionArg("self"))
    _generate_func_args(
        func_generator, url_params, json_params, query_params, extra_params
    )

    if supports_reason:
        func_generator.append_arg(
            FunctionArg("reason", annotation="t.Optional[str]", default="None")
        )
        needed_imports.append("typing")
    if supports_files:
        func_generator.append_arg(
            FunctionArg("files", annotation="UnsetOr[list[BasicFile]]", default="Unset")
        )
        needed_imports.append("BasicFile")

    # generate body
    fmted_url_params = ""
    if url_params is not Unset:
        fmted_url_params += ", " + ", ".join([f"{name}={name}" for name in url_params])

    fmted_extra_params = ""
    if json_params is not Unset:
        fmted_extra_params += ", json_params={"
        fmted_extra_params += ",".join(
            [f'"{param_name}":{param_name}' for param_name in json_params]
        )
        fmted_extra_params += "}"
    if query_params is not Unset:
        fmted_extra_params += ", query_params={"
        fmted_extra_params += ",".join(
            [f'"{param_name}":{param_name}' for param_name in query_params]
        )
        fmted_extra_params += "}"
    if extra_request_params is not Unset:
        fmted_extra_params += ", " + ", ".join(
            [
                f"{param_name}={param_value}"
                for param_name, param_value in extra_request_params.items()
            ]
        )

    if supports_reason:
        fmted_extra_params += ", reason=reason"
    if supports_files:
        fmted_extra_params += ", files=files"

    if extra_code:
        func_generator.print(*extra_code)
    func_generator.print(
        f'return self.request(Route("{method}", "{url}"{fmted_url_params}){fmted_extra_params})'
    )

    return func_generator.generate_raw(), needed_imports


def parse_json_file(file: dict[str, t.Any]) -> str:
    funcs: list[str] = []
    name = _dict_type_check(file, "name", str)
    methods: dict[str, t.Any] = _dict_type_check(file, "methods", dict[str, t.Any])
    requires: UnsetOr[list[str]] = _dict_type_check(
        file, "requires", list[str], is_required=False
    )

    imports = ""
    used_imports: list[str] = []
    if requires is not Unset:
        for requirement in requires:
            imports += f"{IMPORTS[requirement]}\n"
            used_imports.append(IMPORTS[requirement])

    for func_name, func_metadata in methods.items():
        func, needed_imports = parse_endpoint_func(func_name, func_metadata)
        funcs.append("\n".join([indent(line) for line in func.splitlines()]))
        for import_ in needed_imports:
            if import_ not in used_imports:
                imports += f"{IMPORTS[import_]}\n"
                used_imports.append(import_)

    return FILE_TEMPLATE.format(
        imports, name, "\n\n".join(funcs) if len(funcs) else indent("pass")
    )


#
#  Main
#


def is_path_legit(p: pathlib.Path) -> bool:
    return p.exists() and p.is_dir()


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        prog="generate_endpoints",
        description="A helper for DisCatCore that processes JSON files into HTTP Endpoint functions.",
    )

    parser.add_argument(
        "-s",
        "--source",
        default=DEFAULT_SOURCE_DIR,
        help="The source directory where the JSON files are located.",
    )
    parser.add_argument(
        "-d",
        "--destination",
        default=DEFAULT_DEST_DIR,
        help="The destination directory where the generated Python files will be stored.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Whether or not the generated files should be stored. This will print the file's contents to STDOUT.",
    )
    parser.add_argument(
        "--no-overwrite",
        action="store_true",
        help="Whether or not a file that already exists in the destination directory should be overwritten.",
    )
    parser.add_argument(
        "--no-init-generation",
        action="store_true",
        help="Whether or not the __init__ file should be generated.",
    )

    gen_args = parser.parse_args()
    gen_args.init_generation = not gen_args.no_init_generation
    gen_args.overwrite = not gen_args.no_overwrite
    return gen_args


def main() -> None:
    args: argparse.Namespace = parse_args()
    src_dir: pathlib.Path = pathlib.Path(args.source)
    dest_dir: pathlib.Path = pathlib.Path(args.destination)

    if not is_path_legit(src_dir):
        raise ValueError(
            f"Source path {str(src_dir)} is not valid. Please retry with a valid path."
        )
    if not is_path_legit(dest_dir):
        raise ValueError(
            f"Destination path {str(dest_dir)} is not valid. Please retry with a valid path."
        )

    generated_filenames: list[str] = []

    for file in sorted(src_dir.glob("*.json")):
        loaded_file = json.loads(file.read_text())
        if len(loaded_file):
            print("Generating file for JSON metadata", str(file) + "...")

            generated_file = parse_json_file(loaded_file)
            print("Generated file for JSON metadata", str(file) + "!")

            if args.dry_run:
                print(generated_file)
                generated_filenames.append(file.stem)
            else:
                dest_path = dest_dir / f"{file.stem}.py"
                if dest_path.exists() and args.overwrite or not dest_path.exists():
                    if not dest_path.exists():
                        dest_path.touch()
                    with dest_path.open("w") as f:
                        f.write(generated_file)

                    generated_filenames.append(file.stem)
                else:
                    print(
                        "Destination file",
                        str(dest_path),
                        "already exists and overwrite is off! Skipping...",
                    )
                    continue

    if args.init_generation:
        print("Generating file for __init__.py...")
        init_file = INIT_HEADER

        for filename in sorted(generated_filenames):
            init_file += f"from .{filename} import *\n"

        print("Generated file for __init__.py!")
        if args.dry_run:
            print(init_file)
        else:
            dest_path = dest_dir / "__init__.py"
            if dest_path.exists() and args.overwrite or not dest_path.exists():
                if not dest_path.exists():
                    dest_path.touch()
                with dest_path.open("w") as f:
                    f.write(init_file)
            else:
                print(
                    "Destination file __init__.py already exists and overwrite is off! Skipping...",
                )


if __name__ == "__main__":
    main()
